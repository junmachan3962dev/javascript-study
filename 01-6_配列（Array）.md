### 1. 配列とは？

複数のデータに背番号をつけて、一つの変数にまとめて管理する仕組みです。

**基本形**
```
// [ ] で囲み、カンマで区切る
const colors = ["Red", "Green", "Blue"];
```

配列やオブジェクトを取り出す際の重要な記法が下記の２つあります。

■ **ブラケット記法 `[ ]`**

配列で最も使われる方法です。

- **特徴**: `[ ]` の中に**インデックス（数字）や変数**を入れてアクセスします。
- **中身**（要素）が欲しいとき → **ブラケット記法**を使用する。

```
const fruits = ["Apple", "Banana"];

// 数字で指定
console.log(fruits[0]); // "Apple"

// 変数で指定（for文などでよく使う！）
const index = 1;
console.log(fruits[index]); // "Banana"
```

■ **ドット記法 `.`**

配列そのものに対しては、データを取り出すためではなく、「**プロパティやメソッド**」を呼び出すときに使います。

- **特徴**: 変数名の後に `.` をつけて、決まった名前を呼び出します。
- **機能**（メソッド）を使いたいとき → **ドット記法**

```
console.log(fruits.length); // 2（プロパティ）
fruits.push("Orange");      // メソッド（機能）の実行
```

### 2. インデックス（添字）

中身を取り出すときはブラケット記法[　]を使います。

配列の中身を取り出すときは、左から右へ[０]からスタートして、連番で[0]、[1]、[3]．．．と続けます。
```
const colors = [Red, Green, Blue];

console.log(colors[0]); // "Red"
console.log(colors[1]); // "Green"
console.log(colors[2]); // "Blue"
```

### 3. 要素の数（length）

配列にいくつデータが入っているかは、`.length` で取得できます。

```
console.log(colors.length); // 3
```

### 4. 配列の操作（メソッド）

「最後」を操作するのか、「最初」を操作するのかで名前が決まっています。

■ **末尾（うしろ）を操作する**

実務で最も頻出するパターンです。
- **`push()`**: 最後に要素を追加する
- **`pop()`**: 最後の要素を削除する

■ **先頭（まえ）を操作する**

- **`unshift()`**: 最初に要素を追加する
- **`shift()`**: 最初の要素を削除する

```
const list = ["B", "C"];

list.push("D");      // ["B", "C", "D"]
list.unshift("A");   // ["A", "B", "C", "D"]

list.pop();          // ["A", "B", "C"]
list.shift();        // ["B", "C"]
```

### 5. 配列を回すモダンな方法

#### 5-1. for...of 文（配列のためのループ）

基本の `for` 文から「インデックス（`i`）の管理」を取り除いた、配列専用の書き方です。

- **シンプル**: `i < length` や `i++` を書かなくていい。
- **直感的**: 「配列から要素を1つ取り出す」という動きがそのままコードになる。
- **中断できる**: `forEach` と違い、`break` や `continue` が使えます。

```
const colors = ["Red", "Green", "Blue"];

// colorsから1つずつ取り出して color という変数に入れる
for (const color of colors) {
  console.log(color);
}
```

■ **breakを使ったサンプルコード**

ループの処理を途中で完全に終了したい時に使う。
```
const numbers = [1, 2, 3, 4, 5];

for (const n of numbers) {
  if (n === 3) {
    break; // 3に来たら、ループ自体を即終了！
  }
  console.log(n);
}
// 1, 2 だけが表示される
```

■ **continueを使ったサンプルコード**

その回の処理だけを飛ばして「次の周」にジャンプする。
```
const numbers = [1, 2, 3, 4, 5];

for (const n of numbers) {
  if (n % 2 === 0) {
    continue; // 偶数なら、下の処理（console.log）を飛ばして次へ！
  }
  console.log(n);
}
// 1, 3, 5 だけが表示される
```

#### 5-2`forEach`（全実行）

配列の要素すべてに対して、順番に処理を行います。
「**全件処理**」が前提の、**メソッドチェーン（`.filter().forEach()` など）で繋げて書きたいとき**に向いています。

```
const colors = ["Red", "Green", "Blue"];

// 中身を一つずつ color という名前で取り出して処理
colors.forEach((color) => {
  console.log(color);
});
```

**メゾットチェーンで繋げたサンプルコード**
10以上の数字だけを選び（filter）、10倍にして（map）、表示する（forEach）」という流れです。
```
const numbers = [5, 12, 8, 20];

numbers
  .filter(n => n >= 10) // [12, 20] に絞る
  .map(n => n * 10)     // [120, 200] に加工
  .forEach(n => console.log(n)); // 120, 200 を表示
```

#### 5-3 `map`（加工・生成）

元の配列を一つずつ取り出して、加工した結果を **「新しい配列」** として返します。（実務で最頻出！）

```
const numbers = [1, 2, 3];
const doubled = numbers.map((n) => n * 2); // [2, 4, 6]
```

**書き方の内訳（アロー関数）＊基本の書き方**

`(n) => n * 2` の部分は、非常に短く書かれた関数です。

- **`(n)`**: 取り出した一つの要素（名前は自由。numberの `n` など）
- **`=>`**: 「右の処理を実行して返す」という合図
- **`n * 2`**: どんな加工をするか

#### 5-4`filter`（選別）

条件に合うものだけを**抽出**して、新しい配列を作ります。

```
const scores = [50, 80, 40, 90];

//80以上(s >= 80)がtrueのものだけを抽出
const highScores = scores.filter((s) => s >= 80); 

console.log(highScores);  // [80, 90]
```

**ポイント**

- **用途**: データの選別（不要なものの除外）。
- **非破壊**: 元の `scores` は書き換えません。
- **コツ**: DBから届いた大量のデータから、必要な分だけを取り出す時に多用します。


**現場の鉄則：** 基本は `map` / `filter` で「新しい配列」を作る。 元の配列を書き換える `push` などの破壊的メソッドは避ける。


#### 6. 配列のコピーと更新（スプレッド構文）

オブジェクト編でも登場した「ぶちまける」記法は、配列でも必須の武器です。

■ **実際のコード**

```
const list = ["A", "B"];

// 1. コピーして新しいデータを作る
const copyList = [...list];

// 2. コピーしつつ、新しい項目を追加する
const newList = [...list, "C"]; 
```

■ **ポイント**

- **不変性（Immutable）**: `push` を使わず、元の配列を汚さないのがモダンな作法。
- **共通の仕組み**: `{...obj}` も `[...arr]` も、「中身をバラして新しい箱に並べ直す」という仕組みは同じです。
