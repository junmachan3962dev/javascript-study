### 1. クロージャとは何か？

**「関数が、自分が作られた時のレキシカル環境（LE）を、実行コンテキストが消えた後もずっと覚えている仕組み**」のことです。

通常、関数が実行を終えると「実行コンテキスト」はスタックから消え、中身も破棄されます。しかし、ある条件を満たすと、その「**レキシカル環境（LE）」だけがメモリ上に残り続けます。**

### 2. クロージャが発生する3つの条件

1. **関数（親）の中に、別の関数（子**）が定義されている。
    
2. 子関数が、親関数のスコープにある**変数（LEの環境レコード**）を参照している。
    
3. 親関数が実行を終えた後も、**子関数がどこかで生き残っている**（戻り値として返されたり、変数に代入されたりしている）。

### 3. メモリの持続性：なぜ消えないのか？

ここが一番のポイントです。

- **スタック（Stack）**: 実行コンテキスト（部屋）が積み重なる場所。**関数の実行が終わった瞬間に即座に（実行コンテキストが）解体される**。
    
- **ヒープ（Heap）**: レキシカル環境（LE）は「**子関数」から参照されている限り消えない（GCが働かない**）。＊**ガベージコレクション（GC）はヒープ領域のみ**
　　

結果として、「**部屋は壊されたのに（実行コンテキスト）、引き出しだけ（LE）が空中に浮いて残っている**」ような状態になります。これがクロージャの正体です。

### 4. クロージャのカプセル化（データの隠蔽）

■ **「カプセル化（データの隠蔽）」とは何か？**

通常の変数は、誰でも中身を見たり、勝手に書き換えたりできます。 しかし、クロージャを使うと、「**中身は外から見えないけれど、特定の関数（子関数）を通したときだけ操作できる**」という状態が作れます。

■ **具体的なコード例：カウンター金庫**

```
function createCounter() {
  let count = 0; // これが「金庫（LE）」の中にある秘密の変数

  return {
    increment: function() {
      count++;
      console.log(`現在の値: ${count}`);
    },
    getValue: function() {
      return count;
    }
  };
}

const myCounter = createCounter();

myCounter.increment(); // 現在の値: 1
myCounter.increment(); // 現在の値: 2

// 直接 count を触ろうとしても...
console.log(myCounter.count); // undefined（外からは見えない！）
```

**なぜ「隠蔽」できるのか？（LEの仕組みで考える）**

1. **直接アクセス不可**: `count` という変数は `createCounter`関数 の **LE（環境レコード）** の中にあります。

2. **唯一の道**: この LE にアクセスできるのは、その中で生まれた「子関数（incrementやgetValue）」だけです（**外部環境参照**のおかげ）。

3. **完全ガード**: 外側のグローバルスコープからは、この LE の中を覗くための「矢印（参照）」がありません。


■ **03-3_クロージャとメモリの持続性：最終まとめ**

ここまで学んだことを「教科書」として一気に統合しましょう。

|**概念**|**役割・場所**|**クロージャにおける動き**|
|---|---|---|
|**実行コンテキスト**|**スタック**（実行の管理）|関数が呼ばれるたびに作られ、終わると**即座に解体**される。|
|**LE（レキシカル環境）**|**ヒープ**（データの保持）|実行時に作られる。子関数からの**参照（命綱）**がある限り、GCに消されない。|
|**環境レコード**|**LEの中**（変数の引き出し）|秘密のデータ（`count`など）を保管する実体。|
|**外部環境参照**|**LEの鎖**|子関数が親のLEを見つけるためのルート。これがあるから「浮いた引き出し」が使える。|

### 5. クロージャのメモリリークについて

クロージャで作ったレキシカル環境（LE）は、子関数への参照が残っている限り、**永遠にヒープを占拠**します。それを**メモリリーク**と言います。
もし巨大なデータをクロージャに持たせ、それを大量に作り続けると、メモリがいっぱいになってブラウザが重くなります。

**対策**： `myCounter = null;` のように変数に `null` を代入すると、子関数への参照が消え、鎖が切れます。するとようやくガベージコレクション（GC）がヒープからレキシカル環境（LE）を掃除してくれます。
