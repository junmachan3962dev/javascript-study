### 1. 「値」と「参照」の決定的な違い

JavaScriptのデータは、メモリへの置かれ方で2種類に分かれます。

- **プリミティブ型（数値、文字列など）**: 変数という箱の中に、**データそのもの**が入ります。
    
- **オブジェクト型（オブジェクト、配列、関数など）**: 変数という箱の中には、データそのものではなく、「**データが置かれているヒープ領域の住所（参照）**」が入ります。
    
### 2. なぜこれが重要なのか？（共有の罠）

次のコードを見て、何が起きるか予想してみてください。

```
const userA = { name: "田中" };
const userB = userA; // 住所をコピーした！

userB.name = "佐藤";

console.log(userA.name); // さて、結果は何でしょう？
```

正解は **`"佐藤"`** です。 `userB` を変えただけなのに、`userA` まで変わってしまいました。

これは、`userB = userA` としたときに値ではなく参照先すなわち「**ヒープ領域の同じ住所」を共有（参照）してしまったから**です。

＊オブジェクトをコピーすると同じ住所（参照）をコピーする性質があるのでuserAとuserBは同じところを見ている。

### 3. オブジェクトの比較 `===` の謎

「中身が同じなら同じでしょ？」と思いがちですが、参照を知ると納得できます。

```
console.log({} === {}); // 結果は false
```

結果は**false**です。 **`===`（比較演算子**）は 2つの変数が持つ住所を「**照らし合わせる**」行為だからです。


### 4. 代入と比較の決定的な違い

- **`=`（代入）**: 住所を「**コピー**」して、同じ家を見させる行為。
    
- **`===`（比較）**: 2つの変数が持つ住所を「**照らし合わせる**」行為。
    
- **オブジェクトの性質**: `{}` と書くたびに、ヒープ領域の「新しい住所」が発行される。だから、代入を通さない限り `===` は `true` になり得ない。


### 5. スプレッド構文のシャロ―コピーとディープコピー

#### 5-1 シャロ―コピー（Shallow Copy）

**「スプレッド構文はシャロ―コピーです」**

- **スプレッド構文の仕組み（シャロ―コピー）**

    - **1層目のプロパティ**（数値や文字列など）は、完全に独立してコピーされる。
    
    - **2層目以降（ネスト）のオブジェクト**は、中身ではなく「住所（参照）」がコピーされるため、コピー先とコピー元で同じ実体を共有してしまう。
    
    - 2層目まで完全に独立させたい場合は、スプレッド構文ではなく `structuredClone()`（ディープコピー）が必要。

```
const userA = {
  name: "田中",      // これが「直属（1階）」
  age: 30,          // これも「直属（1階）」
  hobby: {          // この『hobby』という名前自体は「1階」
    main: "登山"     // でも、その中身（main）は「2階（ネスト）」
  }
};
```

 **罠の正体**：
- スプレッド構文（`...`）は、**「一番外側の箱」だけを新築する**もの。 中に入っているのが「数値」ならそのままコピーされますが、中に入っているのが「別のオブジェクト」なら、**住所がそのままコピー**されてしまいます。
- スプレッド構文をコピーしてコピー先でオブジェクトの値を変えると元データも変わってしまう。


#### 5-2 ディープコピー（Deep Copy）

- **ディープコピーは**オブジェクトのネストの最深部まで、完全に新しい住所（参照）を割り当てて、全く新しい住所（参照）のコピーを作り出す。**なのでコピー先のネストしたオブジェクトの中身を変えても元データには影響しない**。

- `structuredClone()`を使用してディープコピーをする。

■ **ディープコピーの仕組み**

ディープコピーを実行すると、JavaScriptはオブジェクトの中身を芋づる式に追いかけます。

- **1階層目**：新しい住所にコピー。
    
- **2階層目（オブジェクト）を見つけたら**：それも無視せず、さらに新しい住所を作って中身をコピー。
    
- **3階層目、4階層目...**：中身がなくなるまで、すべて新しい住所を割り振り続ける。
    
結果として、元のオブジェクトとは「見た目は同じだが、全パーツの住所が異なる」という、**完全に独立したクローン**が誕生します。

■ **`structuredClone()`の使い方**

```
const userA = {
  name: "田中",
  details: { 
    city: "東京",
    tags: ["エンジニア", "登山"] // 3階層目（配列）
  }
};

// 【ディープコピー実行】
const userB = structuredClone(userA);

// userBの深いところ（3階層目）を書き換えてみる
userB.details.tags.push("キャンプ");

// userAは無傷のまま！
console.log(userA.details.tags); // ["エンジニア", "登山"]
console.log(userB.details.tags); // ["エンジニア", "登山", "キャンプ"]
console.log(userA.details === userB.details); // false (住所が違う！)
```

`const userB = structuredClone(userA);`の部分にJavaScriptが実行フェーズで到達したら、元データとは全く違う住所（参照）を割り当てる。なのでコピー先のデータを変えてもコピー元は影響を受けない。

「**ディープコピーは副作用を完全に遮断する手法である**」

＊**副作用とは**：元データに影響を与えてしまうこと。プロの現場では**副作用（Side Effect）がある」** と呼びます。

#### 5-3. なぜ最初からこれを使わないのか？（デメリット）

「全部ディープコピーにすれば安全じゃないか」と思いますよね。でも、これには明確な理由があります。

- **コスト（重さ）**: スプレッド構文は「表面をなぞるだけ」なので一瞬で終わりますが、ディープコピーは「中身をすべてスキャンして新築し続ける」ため、データが巨大だとパソコンのメモリやCPUを激しく消耗します。
    
- **特殊なデータの消失**: 関数（メソッド）などが含まれているオブジェクトの場合、`structuredClone` ではコピーできない（エラーになる）ことがあります。

#### 5-4 使い分け

- **シャローコピー**: 処理が爆速。1階建ての単純なデータならこれで十分。
    
- **ディープコピー**: 処理が少し重い。複雑で巨大なデータ（設定ファイルや、複雑なユーザーデータなど）を扱うときに使う。



