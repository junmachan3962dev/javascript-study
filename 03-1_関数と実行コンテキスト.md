### 1. 実行コンテキスト 

■ **実行コンテキストExecution Contextとは**

- Javascriptコードが評価され、実行される際の「環境」を抽象化した概念をいう。
- コードが実行される際に必要な情報（変数、関数、thisの値など）を管理する枠組みのことです。

■ **実行コンテキストには２種類あります。**

- **グローバルコンテキスト**
    - プログラムが開始される時に最初に作成されるデフォルトのコンテキストです。
    - ブラウザではwindowオブジェクト、Node.jsではglobalオブジェクトが作成される。

- **関数コンテキスト**
    - 関数が呼び出されるたびに、その関数専用のコンテキストが新しく作成されます。

■ **実行コンテキストの構成要素**

- **変数環境（Variable Environment）**
    varで宣言された変数や関数宣言を保持します。

- **レキシカル環境（Lexical Environment）**
    - レキシカル環境は２つの環境があります。
        1. **環境レコード（Environmento Record**）：中身（変数や関数）。
        2. **外部環境参照（Outer Environment Reference**）：外へのルート。スコープチェーンともいう。
    - letやconstで宣言された変数や、外部環境への参照（スコープチェーン）を保持します。

- **Thisの決定**
    そのコード内でthisが何を指すかを決定します。

■ **環境レコード（LR）には２種類ある**

- **宣言的環境レコード (Declarative Environment Record)**
    
    - **場所**: **通常の関数**のコンテキスト。
    - **役割**: `let`, `const`, `arguments` など、プログラムで宣言された変数を直接管理する「普通の引き出し」です。
        
- **オブジェクト環境レコード (Object Environment Record)**
    
    - **場所**: **グローバルコンテキスト**、または `with` 文。
    - **役割**: `window` や `document` のような、**「すでにあるオブジェクト」と変数を結びつける**ための特殊な引き出しです。


### 2. 実行スタック（コールスタック）

JavaScirptエンジンは、「実行スタック（コールスタック）という仕組みを使って、どのコンテクストが現在実行中かを管理します。

1. 新しい関数が呼ばれると、そのコンテキストがスタックの「上」に積まれます（Push）。
2. 関数の実行が終わると、そのコンテキストはスタックから取り除かれます（Pop)。
3. Javascriptはシングルスレッドであるため、常にスタックの最上部にあるコンテキストのみが実行されます（LIFO形式の管理）。

### 3. 環境レコード

- LE（レキシカル環境）の中にある「変数を保管している棚」のことです。
- 実行コンテキストが「部屋」なら、LEは「収納ユニット」、環境レコードは「引き出し」に相当します。

■ **役割：名前と値の管理**

- LE（レキシカル環境）の中にある「変数と値の対応表」で、例えば`const x = 10`とあれば、xという名前に10を紐づけて保管する。
- 実行前に「名前の登録」だけ済ませるため、これがJavaScript特有の「巻き上げ」の原因になる。

■ **中に入っているもの**

- **宣言されたすべての変数（let, const, var**）
- **関数の宣言（function 形式**）
- **引数(arguments**)の情報
＊**arguments**とは「その関数に渡された引数のすべて」を詰め合わせた、特別な配列のようなオブジェクトのことをいう（ [ "A", "B", ... ] ）。
カタカナ読み: **オーギュメンツ** か**アーギュメンツ**です。
### 4. 外部環境参照（Outer Environment Reference）

関数が作成される時に、その関数が「書かれた場所（レキシカルスコープ）」の親環境を記憶する仕組みです。
1. **検索の開始**
    現在の実行コンテキスト内にあるLEの中にある外部環境参照をたどって、親のLEへ移動します。
2. **連鎖（チェーン**）
    見つからない場合、LEの中にある外部環境参照をたどって、親のLEへ移動します。
3. **終着点**
    これを繰り返し、最終的にグローバルコンテキストのLEでも見つからない場合、`ReferenceError`となります。

### 5. Thisの決定

- 実行コンテキストが作られる時、そのコード内で使われるthisというキーワードが「何を指すか」で決定します（動的スコープ）。

■ **thisが決まる４つの代表的なルール**

**①メゾットとして呼ぶ（ドットの前）**

   オブジェクトの関数として呼ばれた場合、thisはその「ドットの左側のオブジェクト」になります。
   `user.sayHello()`→thisは**user**です

**②単独の関数として呼ぶ**

   どこにも属さず、ただの関数として呼ばれた場合、thisは「グローバルオブジェクトになります。
   `sayHello()`→thisは**window**です

**③アロー関数で呼ぶ**

   アロー関数には自分のthisがなく、外側のコンテキストのthisをそのまま使います。

**④new演算子で呼ぶ**

   newをつけて関数（コンストラクタ）を呼び出した場合、thisは「新しく生成された空のオブジェクト」を示します。
   `const person = new User()`→thisは**person**（新しいインスタンス）



