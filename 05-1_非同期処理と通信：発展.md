## 非同期処理の基本知識

### 1. なぜ「非同期」が必要なのか？

JavaScriptには、ある大きな特徴（弱点）があります。

それは、**「一度に一つのことしかできない（シングルスレッド）**」ということです。

もし、すべての処理を順番通り（同期処理）に行うと、こんな問題が起きます。

- **問題発生**: ネットから1,000件のデータを取ってくる命令を出した。
    
- **停止**: データが届くまでの「3秒間」、JavaScriptは通信にかかりきりになり、他の作業（クリックへの反応、画面の更新）をすべてストップさせる。
    
- **結果**: その3秒間、ユーザーの画面は**フリーズ**し、ボタンを押しても反応しない。

これを防ぐために、**「時間のかかる仕事は裏側に放り投げて、終わるまで別の仕事を続ける」という仕組みが必要になります。これが非同期処理**です。

### 2.  **非同期処理のメカニズム**

1. **外部へ投げる**: JSが「fetch（通信）」という命令を読むと、すぐにその仕事を**外部（Web API**）へ投げます。
    
2. **JSは次へ進む**: 仕事を投げた瞬間に、JSの職人は「予約票（Promise）」だけを受け取って、**次の行の実行へ移ります**。
    
3. **外部で待機**: **外部（Web API**）が、ネットの向こう側からデータが届くのをじーっと待ちます。このときJSの調理場は空いているので、ユーザーのクリックに反応したりできます。
    
4. **結果が戻る**: 通信が終わると、外部から「終わったよ！」と報告が来ます。
    
5. **割り込み（イベントループ）**: JSの職人が今の仕事を終えて手が空いたタイミングで、届いたデータを料理（処理）し始めます。

### 3. 外部処理の種類とイベントループの優先順位

■ **「外部」で処理されるものの正体**

外部に投げられるのは、通信だけではありません。主に以下の3つが代表的です。

- **タイマー**: `setTimeout`（「3秒後に呼んで！」と時計を預ける）

- **通信**: `fetch`（「データを取ってきて！」と郵便を出す）

- **監視（イベント）**: `addEventListener` や `IntersectionObserver`（「クリックされたら」「画面に入ったら」教えて！とセンサーを仕掛ける）

これらはすべて、**JSの調理場（メインスレッド）の外**にある、ブラウザの別部署が担当しています。

■ **戻ってきた処理の「待機場所」：タスクキュー**

ここが一番重要なポイントです。外部で処理が終わっても、**いきなりコールスタック（実行中の行列）には割り込めません。**

外部から戻ってきた「終わったよ！」という報告（コールバック関数）は、**「タスクキュー（またはマイクロタスクキュー）**」という別の行列に並んで待機します。

■ **マイクロタスクキューとタスクキュー**

マイクロタスクキューの方が圧倒的に優先度が高い

|**行列の名前**|**並んでいる主な処理（種類）**|**イメージ**|
|---|---|---|
|**マイクロタスクキュー** (Microtasks)|**Promise関連** (`.then`, `await` の続き)|**VIP行列**。終わるまで次の仕事へ行かせない。|
|**タスクキュー** (Macrotasks)|`setTimeout`, `setInterval`, イベント(`click`など)|**一般行列**。1つ処理したら一回休憩。
  
■ **処理される順番（優先順位のルール）**

JavaScriptの職人（イベントループ）は、以下のような優先順位で仕事をします。

1. **コールスタック**: 今目の前にある仕事を全部終わらせる。（スタックが空になったら直ちに）

2. **マイクロタスク（VIP）**: VIP行列に誰か並んでいたら、**全員分**を片付けるまで他には行かない。

3. **レンダリング**: 画面を更新する（ブラウザの描画タイミング）。

4. **タスクキュー（一般）**: 一般行列の**先頭の一人だけ**を処理する。（一人終わるごとに、VIP行列に新しい人が並んでいないか確認に戻る）

5. **また1に戻る**: そして、再びVIP行列（マイクロ）が空か確認する。

＊マイクロタスクキューで複数待機している場合は、先頭の処理が終わったら続けて処理を行い、なくなるまで処理を続ける。

＊**「データの更新（マイクロ）」は、次の「画面の更新」より前に、最優先で終わらせる！** という設計思想があるからです。

■ **注意点**

fetch（通信）で戻ってきたデータの量が多い場合フリーズの可能性がある。
**対策**：`setTimeout`などで重い処理を小分けにしてタスクキューに投げる


## 非同期処理の具体的な書き方

### 1. 非同期の 3 つの状態（Promise）

JavaScriptでは、非同期の予約票のことを Promise（プロミス：約束） と呼びます。

この予約票には、必ず以下の「3つの状態」が存在します。

|**状態**|**意味**|**イメージ**|
|---|---|---|
|**Pending（待機中）**|まだ結果が出ていない|料理を注文して、キッチンで作っている間|
|**Fulfilled（成功）**|無事に完了した|料理が運ばれてきた！（次の「食べる」工程へ）|
|**Rejected（失敗）**|何らかの問題で中止|「材料切れです」と断られた（「別の店を探す」工程へ）|

### 2. モダンな書き方：`async` と `await`

昔は複雑な書き方をしていましたが、今は「**非同期だけど、見た目は上から順に書く**」という魔法の定型句を使います。async / await は 糖衣構文（Syntactic sugar）です。

**基本構文**
```js
async function fetchUser() {

  try {
    const response = await 
    fetch("https://jsonplaceholder.typicode.com/users/1");
    
    if(!response.ok) {
      throw new Error("エラーが発生しました。ステータスコード：" `${response.status}`);
    
    }
      const userData = await response.json();
      console.log("ユーザー名：", userData.name);
    
    } catch (error) {
      console.error("エラーの詳細：", error.message);
    
    } finally {
      console.log("処理が完了しました");
    
    }
}

fetchUser();
```

**コードの解説**
- **`async function ～`**：`async`で非同期だということを宣言している。
- **`const response = await fetch(...)`**：`await`で外部からの通信が終わるまで待機している状態。
- **`if (!response.ok) {throw new Error(...)}`**：通信が成功したかチェックしている。エラーの場合は`throw`により以降のコードの実行が停止し`catch`ブロックへ緊急避難する。
- **`const userData = await response.json();`**：生データをjson形式に変換している。これも時間がかかる処理なので`await`が必要。
- **`catch (error) {console.error(...);}`**：失敗（reject）したときのエラーハンドリング。
- **`finally {console.log(...);}`**：処理の最後に、結果に関係なく絶対やっておきたいことを書く場所。例えば、ローディング画面を消すとかボタンを再度押せるようにするなど。
  
■ **fetchの成功判定`if (!response.ok)`が必要な理由**

  `fetch` は、たとえサーバーから **「404 Not Found（ページがない）」** や **「500 Error（サーバー故障）」** が返ってきても、通信自体は成功（Fulfilled）したとみなして `catch` に飛んでくれないという性質があるからです。

### 3. **エラーコードの種類と発信先**

#### 3-1. どこから発信されるのか？

エラーコードはブラウザとサーバーから発信される

|**発信元**|**タイミング**|**内容**|
|---|---|---|
|**ブラウザ（JS）**|通信が始まる前、または通信自体が遮断された時|そもそも宛先が間違っている、ネットに繋がっていない等。|
|**サーバー（外部）**|郵便（リクエスト）が相手に届いた後|「そんなデータはない」「今は忙しい」など相手からの返事。|
＊`fetch` は「通信が物理的に失敗したとき（断線など）」だけ `catch` へ行き、「404エラー（相手の返事）」のときは `try` の中をそのまま進みます。

#### 3-2. サーバーからの返事：HTTPステータスコード

`response.status` とは、サーバーから返ってくる「**3桁の数字（ステータスコード**）」のことです。

| **数字 (status)** | **意味**                  | **主なチェック箇所**      |
| --------------- | ----------------------- | ----------------- |
| **200**         | **成功（OK）**              |                   |
| **404**         | **宛先不明（Not Found）**     | **URlをチェック**      |
| **500**         | **相手の故障（Server Error）** | **サーバー側をチェック**    |
| **403**         | **立ち入り禁止（Forbidden）**   | **ログイン状態などをチェック** |

＊**個別にエラーメッセージを出すときはif文の中に書く。**
```
if (response.status === 404) {
  throw new Error("指定されたユーザーが見つかりませんでした。");
}
```

＊**エラーをどう見せるかの書き方（伝え方）**

- **404のとき**：「お探しのページは見つかりませんでした。トップへ戻る」　ボタンを出す。
- **500のとき**：「現在サーバーが込み合っています。時間をおいてお試しください」　と優しく伝える。
- **通信が遅いとき**：読み込み中（スケルトンスクリーンやスピナー）を表示して不安にさせない。

＊**「タイムアウト」という概念**
   あまりにも処理が遅い場合は「いつまで待たせるか？」を決めるのが「タイムアウト（Timeout）」です。
   **現場の工夫**：30秒待っても返事がなければ、強制的にエラー画面を出して「**再試行**」を促す。（下記の`AbortController`の項目で解説）

＊**エラーの時の確認方法**
　コードで`status`を確認すると同時に、ブラウザのディベロッパーツールの「**Network**」タブを確認する。赤い文字（404や500など）で原因が書いてある。

#### 3-3. ブラウザ（JS）が出すエラー

■ **よくある「ブラウザ側エラーの原因と対処**

|**原因**|**エラーの内容**|**対処法**|
|---|---|---|
|**オフライン**|`NetworkError` / `Failed to fetch`|ユーザーに「ネット接続を確認してください」と促す。|
|**URLミス**|`TypeError`|コード内のURLが間違っていないか、スペルをチェックする。|
|**CORSエラー**|`CORS policy error`|（開発中によくある）許可されていない相手にデータを送ろうとしている。|
|**タイムアウト**|`AbortError`|応答が遅すぎるので、処理を中断して再試行ボタンを出す。|

■ **コードでの具体的な守り方**

サーバーからの返事（`response.status`）は `try` の中で判定しますが、ブラウザレベルの致命的なエラーは **`catch` ブロック** で捕まえます。

```
} catch (error) {
  // ブラウザが通信を断念した時にここに来る
  console.error("通信の準備段階で失敗しました:", error.message);
  
  if (!navigator.onLine) {
    console.error("原因：オフラインです");
    // UIへの反映例: 「インターネットに接続してください」という警告を出す
  } else {
    console.error("原因：URL間違い、またはサーバーが応答していません");
  }
}
```
`navigator.onLine`は「ユーザーのデバイスが通信できる状態にあるかどうかの第一チェック」として使われる
- `navigator.online == false`：自分のせい（ネット切れ）
- `else`： 自分のミス（URL間違い）or 相手のせい（サーバーダウン）

＊これらを使い分けると、ユーザーに「次に何をすべきか」を正しく教えられる。

■ **URL間違いは「404」か「catch」か？**

- ドメイン（住所）が合っている場合は、**404（サーバーエラー）。**
- ドメイン（住所）が間違っていれば住所自体が存在しないので、**catch（ブラウザエラー）**。

■ **ブラウザエラーが起きた時の対処方法**

ブラウザエラーが起きた時、ユーザーは「アプリが壊れた！」と一番不安になります。以下の3ステップで対処するのがプロの仕事です。

1. **即座に通知**: ぐるぐる回る読み込みアイコン（スピナー）を止めて、「通信に失敗しました」と表示する。
2. **状況を推測して伝える**: 「電波の良い場所で再度お試しください」など、ユーザーができる行動を提示する。
3. **再試行（リトライ）ボタン**: ページ全体をリロードしなくても、その通信だけをやり直せるボタンを置いておく。

### 4.`AbortController`について

`fetch`は一度実行すると、基本的には「返事が来るまで」止まりません。しかし、実際のアプリでは「やっぱり今の通信、やめたい」という場面がよくあります。

- **連打防止**：ユーザーが検索ボタンを１０回連打したとき、前の９回分の通信は無駄なので止めたい。
- **画面遷移**：データを読み込んでいる最中にユーザーが別のページに移動したとき、もうデータは不要なので通信を切りたい。
- **タイムアウト**：「１０秒待っていても返事がなければ、こっちから通信をあきらめる」という処理をしたい。

これらをスマートに解決するのが`AbortController`です。

■ **実装の「３ステップ」**

今の`fetch`コードに、以下の３パーツを組み込むだけです。

1. **コントローラーを作る**：`new AbortController()`
2. **信号（signal）をfetchに渡す**：「この信号が赤になったら止まれ」と伝えておく。
3. **中止を実行する**：`contoroller.abort()`を呼ぶ

**具体的なコード（AbortController対応）**
```
async function fetchWithTimeout(url, timeout = 10000) { //timeout=10000はデフォルト引数
  // 1. AbortControllerの初期化
  const controller = new AbortController();
  const { signal } = controller;

  // 指定した時間（デフォルト10秒）が経過したら中断を実行する
  const timer = setTimeout(() => controller.abort(), timeout);

  try {
    console.log("通信を開始します...");
    const response = await fetch(url, { signal });

    // 2. サーバーサイドエラーの防衛（404, 500など）
    if (!response.ok) {
      throw new Error(`サーバーエラーが発生しました (Status: ${response.status})`);
    }

    const data = await response.json();
    console.log("取得成功:", data);
    return data;

  } catch (error) {
    // 3. エラーの種類を詳細に切り分ける
    if (error.name === 'AbortError') {
      console.error("原因：タイムアウト（応答が遅いため中断しました）");
    } else if (!navigator.onLine) {
      console.error("原因：オフライン（ネット接続を確認してください）");
    } else {
      console.error("原因：", error.message);
    }
  } finally {
    // 成功しても失敗しても、タイマーは解除する（メモリ節約）
    clearTimeout(timer);
  }
}

// 実行例
fetchWithTimeout('https://jsonplaceholder.typicode.com/users/1');
```

**AbortControllerの実装のポイント**
1. **`AbortController`**: 通信に「期限（タイムアウト）」を設けるために使用。
2. **`signal`**: fetch の第2引数に渡すことで、外部から通信を操作可能にする。
3. **`error.name === 'AbortError'`**: これをチェックすることで、「故障」と「時間切れ」を明確に区別してユーザーに伝えられる。
4. **`finally`**: 成功・失敗に関わらず必ず実行されるブロック。タイマーの止め忘れ（メモリリーク）を防ぐ。

- `new AbortController()`と書くことで、メモリ上に「通信を監視し、いつでも中止ボタンを押せる専用の装置（オブジェクト）」を生成しています。

- **生成されたオブジェクトの中身**
  このインスタンスを作ると、主に2つの重要な役割を持つプロパティがセットで手に入ります。

  1. **`controller.signal`（受信機）**
     `fetch` に渡して、「中止の合図をずっと待機しててね」と伝えるためのプロパティです。
  2. **`controller.abort()`（送信機/メソッド）**
     これを実行すると、`signal` を受け取っているすべての `fetch` に対して「今すぐ止まれ！」という電気信号を送ります。

 ■ **`AbortController` の役割まとめ**
 
 - **役割**: 実行中の `fetch` を途中で強制終了させる。 
 - **判定**: `catch` の中で `error.name === 'AbortError'` を見れば、「失敗」ではなく「意図的な中断」だと区別できる。 
 - **現場の知恵**: 検索フォームなどで「入力するたびにAPIを叩く」ような場合、古い通信をこれでキャンセルして、通信費とメモリを節約するのがプロの常識。
