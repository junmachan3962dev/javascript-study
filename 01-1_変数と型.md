# 01-1_変数とデータ型

## 1. 変数の宣言とメモリの確保

■**変数の種類**

1. **const（定数/Constant）**
   - **再代入:** 不可。
  - **ルール:** 宣言と代入をセットで行う必要がある（後から代入できないため）。
  - **内部挙動:** 評価フェーズでメモリ確保。実行フェーズで代入。それまではTDZにより厳重に保護される。

2. **let（変数）**
  - **再代入:** 可能。
  - **ルール:** 宣言だけ先にし、後から代入が可能。
  - **内部挙動:** 評価フェーズでメモリ確保。代入されるまでは `undefined` ですらなく、アクセス不可（TDZ）。

3. **var（従来の変数）**
  - **特徴:** 評価フェーズでメモリ確保と同時に **`undefined` で初期化** されてしまう。
  - **リスク:** 宣言より前で呼び出してもエラーにならず `undefined` が返るため、バグに気づきにくい。

■**変数宣言と代入**

変数を宣言する（`let x;` など）と、コンピュータのメモリの中に、データを置くための「**住所**」が一つ予約されます。

- **宣言（Declaration）**: メモリに場所を確保すること。（評価フェーズ）
- **代入（Assignment）**: 確保した場所にデータを書き込むこと。（実行フェーズ）

## 2. 巻き上げ（Hoisting）の正体

JavaScriptはコードを実行する前に、まず全体をスキャンして（評価フェーズ）「宣言」を探し、メモリ空間を先に確保します。

- これにより、コード上では下に書いた宣言が、内部的には「**上に引き上げられた**」ように振る舞います。
- ただし、`let` や `const` は実行されるまでアクセスできない仕組み（**TDZ**）があるため、安全に保たれています。

## 3. スタック領域とデータ型

■**データ型の種類**

**①プリミティブ型（スタック領域に保存）**
データのサイズ（容量）が固定されており、シンプルで軽量なデータです。これらは**スタック領域**という、読み書きが非常に高速な場所に「値そのもの」が保存されます。

- **Number（数値）**：整数や小数。
- **String（文字列）**：文字の並び。引用符で囲む。
- **Boolean（真偽値）**：`true`（真）と `false`（偽）で判定。
- **undefined**：宣言はされたが、値がまだ代入されていない状態。
- **null**：意図的に「空」であることを示す値。
- **Symbol / BigInt**：一意の識別子や、非常に大きな整数を扱うための型。

＊**不変性（Immutable）について**
**プリミティブ型はすべて**、メモリ上の値を直接書き換えることができない「**不変（Immutable）**」という性質を持ちます。
- **仕組み**: `let s = "Hello";` のあとに `s = "World";` と代入しても、元の `"Hello"` が書き換わるわけではありません。
- **メモリの動き**: 新しく `"World"` という値が別の場所に作られ、変数が指し示す「住所」が切り替わるだけです。

② **参照型（ヒープ領域に保存 / 今後の項で詳しく実施）**
オブジェクト、配列、関数などがこれに当たります（プリミティブ型以外のすべての型）。これらはデータ量が変動し、サイズが大きくなる可能性があるため、**ヒープ領域**という広大な場所に保存されます。

- **なぜ分けるのか？**:
    - **スタック**：本棚の「手前の棚」のように、すぐに取り出せるが容量に限界がある。 
    - **ヒープ**：巨大な「倉庫」のようなもので、何でも入るが取り出すのに少し手順（住所の参照）が必要。
- **内部の繋がり**: 参照型を扱うとき、スタック領域には「ヒープ領域のどこに実体があるか」という**住所（参照情報**）だけが記録されます。

## 4. 型と値（動的型付け）

JavaScriptは「動的型付け言語」と呼ばれ、変数と型の関係に以下の特徴があります。

■**変数ではなく「値」が型を持つ**

変数そのものには「これは数値専用の箱」といった決まりはありません。その時々に代入されている「**値**」の種類によって、変数の型がその都度決まります。
＊**変数はメモリの予約をするだけ**。実行フェーズで値が代入された瞬間に型が決定します。

- **動的型付け:** プログラムの実行中に、代入される値に応じて型が自動的に変わる仕組み。
- **typeof 演算子:** 今、その変数（の中の値）が何型なのかを調べることができます。（詳細は [[01-2_演算子]]にて解説）
- **メリット:** 一度宣言した後は、**変数名だけでアクセス**でき、どんな型の値でも自由に上書きできるため、素早くコードが書けます。
```
console.log(typeof 100);       // "number"
console.log(typeof "Hello");   // "string"
console.log(typeof true);      // "boolean"
console.log(typeof undefined); // "undefined"
```
 ＊**typeof null の注意点**： 内部的なバグにより `typeof null` は `"object"` を返しますが、`null` はあくまでプリミティブ型です。

■**内部的なイメージ**

1. `let data = 100;` → この時、変数 `data` の型は `Number` として振る舞います。
2. `data = "こんにちは";` → 同じ変数に別の型を代入すると、`data` の型は即座に `String` へと切り替わります。

