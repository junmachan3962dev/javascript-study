### 1. なぜDOM操作の「最適化」が必要なのか？

JavaScriptでブラウザの表示（DOM）をいじるとき、実は裏側で**猛烈に重い処理**が走っています。

- **DOMは「高級品」**: JavaScriptからDOMを操作するのは、国境を越えて荷物を運ぶようなもので、時間とコストがかかります。
   
- **リフローとリペイント**: 1つの要素を書き換えるたびに、ブラウザは「要素の配置（リフロー）」を計算し直し、「色や形の描画（リペイント）」をやり直します。
    
「100個のリストを追加する」ときに、100回DOMを操作するのは非効率です。そこで**最適化**が登場します。

### 2. 最適化の方法

### 2-1. ドキュメント断片（DocumentFragment）

**Fragment**：「本物のDOMツリーから切り離された、独立した小さなメモリ空間」をいう。

「100個のリストを1つずつ追加（100回工事）」するのではなく、「**メモリ上の仮想的な作業スペースで100個作り、最後に1回だけガッチャンコする**」方法です。

```
const list = document.getElementById("myList");
// 1. メモリ上の「仮の作業場」を作る（画面にはまだ出ない）
const fragment = document.createDocumentFragment();

for (let i = 0; i < 100; i++) {
  const li = document.createElement("li");
  li.textContent = `アイテム ${i}`;
  // 2. 作業場（住所）にどんどん追加していく
  fragment.appendChild(li);
}

// 3. 最後に1回だけ、本物のDOMにガッチャンコ！
list.appendChild(fragment);
```

**コードの解説（住所の動き）**

1. **仮の空き地（Fragment）を作る** 
   `const fragment = document.createDocumentFragment();` ： メモリ上に画面とは繋がっていない「**透明な仮の住所**」を発行します。

2. **for文の中で「新しい要素」を次々新築する** 
   `const li = document.createElement("li");` ： 1つずつ新しい `li`（住所）を作ります。

3. **新築した要素を「仮の空き地」にどんどん入れる** 
   `fragment.appendChild(li);` ： **ここがポイント！** 本番のDOMではなく、まだ「仮の住所」に合流させています。この時点では画面には何も起きないので、ブラウザは全く疲れません。

4. **最後に「仮の空き地」ごと本番に合体させる** 
   `ul.appendChild(fragment);` ： 最後に一回だけ合体させる。すると、**Fragment（空き地）という封筒が破かれ、中の100個の `li` だけが、一気に本番の住所録に登録されます。**

### 2-2. イベントデリゲーション（イベント委譲）

■ **イベントデリゲーションとは**

「**個々の子要素（`li`など）にイベントを設定する代わりに、その親要素（`ul`など）にだけイベントを設定し、バブリング（上昇）してくるイベントをまとめて管理する手法」**

前回の項で100個の `li` が一気に画面に並びました。 次に、この100個のどれをクリックしても「クリックされました！」と表示させたい場合の方法をを解説します。

■ **非効率なやり方（100個分設定する）**

`for` 文の中で、1つずつの `li`（子要素 に対して `addEventListener` を設定すると？
100個分の「関数の住所」がメモリを占領します。もしリストが1万個になったら、ブラウザが重くなってしまいます。
 
その場合は以下の**イベントデリケーション**を使用する。

 ■ **イベントデリゲーションを使用する**

```
const list = document.getElementById("myList");

// 親要素にだけ1回設定する
list.addEventListener("click", (event) => {
  // event.target には「実際にクリックされた末端の要素の住所」が入っている
  if (event.target.tagName === "LI") {
    console.log(`${event.target.textContent} がクリックされました！`);
  }
});
```
＊**`event.target`とは**：イベントの発生源を特定する属性のこと。ここでいうところの100個の`li`のうちどれがクリックされたかを特定するために使う。

**イベントデリゲーション：4つの詳細ステップ**

1. **【予約】親の住所に「見張り」を置く** 100個の子供（`li`）それぞれに警備員を配置すると、人件費（メモリ）が莫大になります。そこで、唯一の出入り口である**親（`ul`）の住所にだけ**「誰か通ったら教えて！」と見張り役を1人置きます。
    
2. **【上昇】事件が親まで昇ってくる（バブリング）** 末端の子供（`li`）がクリックされると、その衝撃は「事件発生！」という信号になり、家系図を遡るように**親の住所へ向かって自動的に伝わっていきます**。これを泡に例えて**バブリング**と呼びます。
    
3. **【特定】「実際に踏まれた住所」を特定する** 親の住所に届いた事件レポート（`event`）には、**「どの住所で事件が起きたか**」の記録（`event.target`）が残っています。これを見ることで、親は動くことなく「あ、3番目の部屋の住所だな」と特定できます。
    
4. **【判定】住所が「LI」なら解決！** 親の敷地内には、リスト以外の余白があるかもしれません。そこで「事件の起きた住所は本当に `LI` か？」をチェックし、正しければその住所にある情報（`textContent`）を取り出して処理を完了します。

**バブリングの仕組み**

JavaScriptには、「**子供で起きた事件（クリック）は、親、そのまた親へと報告される**」という性質があります。これを **バブリング（泡のように上がっていくこと）** と呼びます。

- **メリット1**: メモリの節約（関数が1つで済む）。
    
- **メリット2**: **後から追加された要素にも反応する。**（後で手入力して `li` を増やしても、親要素は常に監視しているので、新しい `li` にわざわざイベントを付け直す必要がありません！）

### 2-3. イベントリスナー（基本の待ち伏せ）

最も一般的に使われる「動き」のきっかけです。

- **名前**: `addEventListener`
    
- **定型句**: `[住所].addEventListener("[きっかけ]", [やること]);`
    
- **現代の考え方**: `onclick` 属性とは違い、JavaScript側から後付けで設定する。HTML（見た目）とJS（動き）を分離できる。
    
- **特徴**: 1つの要素に複数の「やること」を設定でき、メンテナンス性が高い。

### 3. DOM操作の「最適化」を使った応用

#### 3-1 **無限スクロール**

手入力で100個も200個もコードに書くのではなく、**「条件を満たしたら（スクロールしたら）、自動で中身を生成して追加する**」という仕組みが作れます。

■ **スクロール読み込み（無限スクロール）の裏側**

スクロールで要素を増やす処理は、以下のようなステップで動いています。

1. **監視**: ユーザーが「一番下」までスクロールしたのを検知する。
    
2. **データ取得**: 次の10件分のデータを取ってくる。
    
3. **組み立て（Fragment）**: 取ってきたデータを10個の `li`（ボタン付き）にする。ここで**ドキュメント断片**を使って、メモリ上でセットを作る。
    
4. **合体**: 最後に1回だけ `appendChild` して、画面を更新する。
    
5. **反応（デリゲーション）**: 新しく増えたボタンも、親要素（`ul`）が**イベントデリゲーション**で見張っているから、すぐ反応できる。

■ **自動で `li` が増える仕組みの3大要素**

1. **データ（ネタ帳）**: あらかじめ1,000個くらいのデータが入った「配列」を用意しておくか、インターネット越しにデータを次々取得します。
    
2. **監視員（イベントリスナー）**: 「画面の一番下までスクロールされたか？」を常に見張ります。
    
3. **建築士（Fragment & Loop）**: 「よし、もっと必要だな」となった瞬間に、`for`文などのループが起動。**ドキュメント断片（Fragment**）を使って、次の20個分の `li` を一瞬で組み立てて本番の `ul` に合体させます。

### 3-2. 交差監視（進化した待ち伏せ）

「スクロールイベント」に代わる、モダンな監視の仕組みです。

- **名前**: `IntersectionObserver`
    
- **役割**: 「画面」と「特定の要素（目印）」が重なったかどうかを監視する。
    
- **メリット（対スクロールイベント）**:
    
    - **軽い**: スクロールごとに計算しないので、スマホの電池を食わず、動きが滑らか。
        
    - **シンプル**: 「今、重なっているか（trueなら重なっている）？」という **`isIntersecting`（キー）** の値を見るだけで済む。
        
- **主な用途**: 無限スクロールの検知、画像の遅延読み込み。
