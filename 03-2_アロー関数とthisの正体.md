### 1. アロー関数と `this` の正体

アロー関数 は、単なる「短縮記法」ではありません。最大の特徴は、「**自分自身の `this` を持たない**」という点にあります。

 ■ **特徴１：`this` の決定権を「放棄」している**

- 通常の関数（`function`）は、実行コンテキストが作られる際に「今回の `this` は誰にしようかな？」と決定するプロセスがありました。

- しかし、アロー関数はこの決定プロセスを**パス（省略**）します。

■ **特徴２：代わりに「外部環境参照」を使う**

- 自分の部屋（コンテキスト）に `this` がないため、アロー関数は「**外部環境参照（ステップ4）**」を使って、一つ外側の部屋に `this` を探しに行きます。

- これを専門用語で **「レキシカルな `this`」** と呼びます。またアロー関数をレキシカル関数ともいう。

■ **特徴3：引数のリスト（arguments） も放棄している**

実はアロー関数は、`this` だけでなく、これまでのステップで学んだ「環境レコード」の中にあったはずの **引数のリスト（`arguments`）も持っていません。**

- **通常の関数**: 実行コンテキストが作られる際、渡された引数をすべて記録した **引数のリスト（arguments**） が自動的に用意される。
    
- **アロー関数**: `this` と同様に、`arguments` も持っていないので、使おうとすると**外部環境参照**を辿って親の関数の `arguments` を見に行ってしまいます。
    

> **現代の解決策**: アロー関数で引数を自由に扱いたい時は、`arguments` ではなく、最新の書き方である **「残余引数 (`...args`)」** を使うのが一般的です。

### 2. 比較：通常の関数 vs アロー関数

「どう呼ばれたか」で決まる通常の関数と、「どこに書かれたか」で決まるアロー関数の違いを整理します。

|**特徴**|**通常の関数 (function)**|**アロー関数 (() =>)**|
|---|---|---|
|**`this` の中身**|呼び出し方でコロコロ変わる（動的）|**書かれた場所**の外側の `this` で固定|
|**`this` の決定**|実行時に決まる|**定義した時**に決まる|
|**new 演算子**|使える（コンストラクタになる）|**使えない**（エラーになる）|

### 3. なぜアロー関数が必要なのか？（実戦でのメリット）

一番のメリットは、「**`this` の迷子」を防げること**です。

```
const user = {
  name: "田中",
  sayLater: function() {
    // 1秒後に名前を呼びたい
    setTimeout(() => {
      // アロー関数なので、外側の sayLater の this（user）をそのまま使う
      console.log(this.name); 
    }, 1000);
  }
};

user.sayLater(); // 1秒後、「田中」と表示される
```

 もしこれが function() だったら`setTimeout` によって「単独の関数」として呼ばれるため、this は window になり、window.name（空っぽ）が表示されてしまいます。
 ＊`setTimeout()`はwindowオブジェクトのメゾットです。
