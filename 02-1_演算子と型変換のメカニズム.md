#### 1. 暗黙の型変換（JSのお節介）

計算時に型が違うと、JSが勝手に型を揃えてしまいます。これがバグの温床です。

- **足し算 (`+`) は文字列に弱い**
  `"5" + 1` → `"51"` （文字列として結合される）

- **それ以外の計算 (`-`, `*`, `/`) は数値に強い**
  `"5" - 1` → `4` （数値に変換して計算してくれる）

- **真偽値（boolean）の計算**
  `true` は `1`、`false` は `0` として計算されてしまいます。
    `true + 1` → **2**
    `false + 1` → **1**
    `true + "5"` → **"true5"** （ここでも足し算の「文字列結合」が優先される）

- **null と undefined の違い**
  ここが一番の落とし穴です。
    `1 + null` → **1** （nullは `0` として扱われる）
    `1 + undefined` → **NaN** （数値ではないので、計算不能になる）


- **オブジェクトや配列の変換**
  これらは計算しようとすると、無理やり文字列に変換されようとします。
    `[10] + 5` → **"105"** （配列の10が文字列になり、5がくっつく）

**対策：** 計算する時は、事前に自分で型を揃えるのがプロの作法です。

#### 2. 比較の鉄則：`==` vs `===`

- `==`（等価演算子）：型を勝手に変換して比較する。**（使用禁止）**
    
- `===`（厳密等価演算子）：型も中身も厳密に比較する。**（常にこれを使う）**

```
console.log(1 == "1");  // true  (型が違うのにYesと言う)
console.log(1 === "1"); // false (正解！別物として扱う)
```

#### 3. 真偽値への変換（Truthy / Falsy）

`if` 文などの条件式では、データが自動的に `true / false` に変換される。 （詳細は [[01-4_演算子の種類と優先順位#5. Truthy（真）と Falsy（偽）について|5. Truthy（真）と Falsy（偽）について]] を参照）
＊`true` は `1`、`false` は `0` として計算されてしまいます。

■ **バグを防ぐ（守り）**

例えば、ユーザーが「0」と入力した時。

```
const count = 0;

if (!count) {
  console.log("入力がありません"); 
}
```

JSは「0はFalsy（偽）」と判定するので、**「0と入力したのに、入力がない」と誤判定**されます。これが「型変換」を知らないとハマる罠です。

■ **if文を削る（攻め）**

逆に、これを利用してコードを短くします。

```
// 「名前が空（Falsy）なら、ゲストと表示する」という処理
const dispName = userName || "ゲスト";
```

「空文字 `""` は Falsy である」というルールを知っているからこそ、この1行が書けます。

＊**注意：** 空の配列 `[]` や空のオブジェクト `{}` は、中身がなくても **`true`** です。
＊**Falsy 5人衆**：`0`, `""`, `null`, `undefined`, `NaN` 以外は全部 `true`。

### 最強の回避策：迷ったら「厳密」に書く

「JSが勝手にどう判断するか」を考えるのが面倒なら、自分でハッキリ指定してしまえばいいんです。

- **× 避けるべき書き方**：`if (!count)` （0なのかnullなのか判別がつかない）
    
- **○ 賢い書き方**：`if (count === 0)` や `if (count === null)`
    

こう書けば、JSのお節介な型変換が発動する余地がなくなるので、ルールをいちいち思い出さなくて済みます。

